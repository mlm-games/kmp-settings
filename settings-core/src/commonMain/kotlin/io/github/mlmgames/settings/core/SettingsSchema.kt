package io.github.mlmgames.settings.core

import kotlin.reflect.KClass

/**
 * Schema definition for a settings data class.
 * Generated by KSP from annotated properties.
 */
interface SettingsSchema<T> {
    /** Default instance of the settings class */
    val default: T

    /** All fields (both @Setting and @Persisted) */
    val fields: List<SettingField<T, *>>

    /** Find field by property name */
    fun fieldByName(name: String): SettingField<T, *>? =
        fields.firstOrNull { it.name == name }

    /** Find field by DataStore key */
    fun fieldByKey(key: String): SettingField<T, *>? =
        fields.firstOrNull { it.keyName == key }

    /** All fields with UI metadata (excludes @Persisted-only) */
    fun uiFields(): List<SettingField<T, *>> =
        fields.filter { it.meta != null }

    /** Group UI fields by category, sorted by order */
    fun groupedByCategory(): Map<KClass<*>, List<SettingField<T, *>>> {
        val grouped = uiFields().groupBy { it.meta!!.category }

        // Sort by category order
        val sortedEntries = grouped.entries.sortedBy { entry ->
            uiFields()
                .firstOrNull { it.meta?.category == entry.key }
                ?.meta?.categoryOrder ?: Int.MAX_VALUE
        }

        // Convert back to LinkedHashMap to preserve order
        return sortedEntries.associate { it.key to it.value }
    }

    /** Get ordered list of categories */
    fun orderedCategories(): List<KClass<*>> =
        groupedByCategory().keys.toList()

    /** Check if a setting is enabled based on its dependency */
    fun isEnabled(model: T, field: SettingField<T, *>): Boolean {
        val meta = field.meta ?: return true
        val dep = meta.dependsOn
        if (dep.isBlank()) return true

        val depField = fieldByName(dep) ?: return true

        @Suppress("UNCHECKED_CAST")
        val value = (depField as SettingField<T, Any?>).get(model)

        return when (value) {
            is Boolean -> value
            is Int -> value != 0
            is String -> value.isNotBlank()
            null -> false
            else -> true
        }
    }

    /** Get fields that can be reset */
    fun resettableFields(): List<SettingField<T, *>> =
        fields.filter { it.meta?.noReset != true }

    /** Get fields in a category that can be reset */
    fun resettableFieldsInCategory(category: KClass<*>): List<SettingField<T, *>> =
        uiFields().filter { it.meta?.category == category && it.meta?.noReset != true }
}